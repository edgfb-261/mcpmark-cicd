name: Pull Request Automation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  # Job 1: Code Quality Checks
  code-quality:
    name: code-quality
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run ESLint
        id: eslint
        run: |
          echo "Running ESLint checks..."
          npm run lint > eslint-results.txt 2>&1 || echo "ESLINT_FAILED=true" >> $GITHUB_OUTPUT
          cat eslint-results.txt
          
      - name: Run Prettier check
        id: prettier
        run: |
          echo "Running Prettier formatting check..."
          npx prettier --check src/ > prettier-results.txt 2>&1 || echo "PRETTIER_FAILED=true" >> $GITHUB_OUTPUT
          cat prettier-results.txt
          
      - name: Post Code Quality Report
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');
            
            let eslintResults = '';
            let prettierResults = '';
            
            try {
              eslintResults = fs.readFileSync('eslint-results.txt', 'utf8');
            } catch (e) {
              eslintResults = 'No ESLint results found';
            }
            
            try {
              prettierResults = fs.readFileSync('prettier-results.txt', 'utf8');
            } catch (e) {
              prettierResults = 'No Prettier results found';
            }
            
            const eslintPassed = !core.getInput('eslint-failed');
            const prettierPassed = !core.getInput('prettier-failed');
            
            const statusIcon = (passed) => passed ? '✅' : '❌';
            
            const commentBody = `## Code Quality Report
n            
            ### ESLint Results
            ${statusIcon(eslintPassed)} ESLint checks ${eslintPassed ? 'passed' : 'failed'}
            
            \`\`\`bash
            ${eslintResults.substring(0, 2000)}
            \`\`\`
            
            ### Prettier Results
            ${statusIcon(prettierPassed)} Prettier formatting ${prettierPassed ? 'passed' : 'failed'}
            
            \`\`\`bash
            ${prettierResults.substring(0, 2000)}
            \`\`\`
            
            ---
            *Generated by PR Automation Workflow*`.replace(/core.getInput\('eslint-failed'\)/g, '${{ steps.eslint.outputs.ESLINT_FAILED }}').replace(/core.getInput\('prettier-failed'\)/g, '${{ steps.prettier.outputs.PRETTIER_FAILED }}');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
        env:
          ESLINT_FAILED: ${{ steps.eslint.outputs.ESLINT_FAILED }}
          PRETTIER_FAILED: ${{ steps.prettier.outputs.PRETTIER_FAILED }}

  # Job 2: Testing Suite
  testing-suite:
    name: testing-suite
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests with coverage
        id: tests
        run: |
          echo "Running test suite with coverage..."
          npm run test:coverage > test-results.txt 2>&1
          TEST_EXIT_CODE=$?
          echo "Test exit code: $TEST_EXIT_CODE"
          
          # Extract coverage summary
          if [ -f coverage/coverage-summary.json ]; then
            echo "Coverage report generated successfully"
            COVERAGE_LINES=$(cat coverage/coverage-summary.json | jq -r '.total.lines.pct // 0')
            COVERAGE_FUNCTIONS=$(cat coverage/coverage-summary.json | jq -r '.total.functions.pct // 0')
            COVERAGE_BRANCHES=$(cat coverage/coverage-summary.json | jq -r '.total.branches.pct // 0')
            COVERAGE_STATEMENTS=$(cat coverage/coverage-summary.json | jq -r '.total.statements.pct // 0')
            
            echo "COVERAGE_LINES=$COVERAGE_LINES" >> $GITHUB_OUTPUT
            echo "COVERAGE_FUNCTIONS=$COVERAGE_FUNCTIONS" >> $GITHUB_OUTPUT
            echo "COVERAGE_BRANCHES=$COVERAGE_BRANCHES" >> $GITHUB_OUTPUT
            echo "COVERAGE_STATEMENTS=$COVERAGE_STATEMENTS" >> $GITHUB_OUTPUT
          else
            echo "No coverage report found"
            echo "COVERAGE_LINES=0" >> $GITHUB_OUTPUT
            echo "COVERAGE_FUNCTIONS=0" >> $GITHUB_OUTPUT
            echo "COVERAGE_BRANCHES=0" >> $GITHUB_OUTPUT
            echo "COVERAGE_STATEMENTS=0" >> $GITHUB_OUTPUT
          fi
          
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "TESTS_FAILED=true" >> $GITHUB_OUTPUT
          fi
          
          cat test-results.txt
          
      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: coverage/
          retention-days: 7
          
      - name: Post Test Coverage Report
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');
            
            let testResults = '';
            try {
              testResults = fs.readFileSync('test-results.txt', 'utf8');
            } catch (e) {
              testResults = 'No test results found';
            }
            
            const lines = core.getInput('coverage-lines') || '0';
            const functions = core.getInput('coverage-functions') || '0';
            const branches = core.getInput('coverage-branches') || '0';
            const statements = core.getInput('coverage-statements') || '0';
            const testsFailed = core.getInput('tests-failed') === 'true';
            
            const statusIcon = (pct) => parseFloat(pct) >= 70 ? '✅' : '⚠️';
            
            const commentBody = `## Test Coverage Report
            
            ### Test Execution
            ${testsFailed ? '❌' : '✅'} Tests ${testsFailed ? 'failed' : 'passed'}
            
            ### Coverage Summary
            | Metric | Coverage | Status |
            |--------|----------|--------|
            | Lines | ${lines}% | ${statusIcon(lines)} |
            | Functions | ${functions}% | ${statusIcon(functions)} |
            | Branches | ${branches}% | ${statusIcon(branches)} |
            | Statements | ${statements}% | ${statusIcon(statements)} |
            
            ### Test Output
            \`\`\`bash
            ${testResults.substring(0, 1500)}
            \`\`\`
            
            ---
            *Generated by PR Automation Workflow*`.replace(/core.getInput\('coverage-lines'\)/g, '${{ steps.tests.outputs.COVERAGE_LINES }}').replace(/core.getInput\('coverage-functions'\)/g, '${{ steps.tests.outputs.COVERAGE_FUNCTIONS }}').replace(/core.getInput\('coverage-branches'\)/g, '${{ steps.tests.outputs.COVERAGE_BRANCHES }}').replace(/core.getInput\('coverage-statements'\)/g, '${{ steps.tests.outputs.COVERAGE_STATEMENTS }}').replace(/core.getInput\('tests-failed'\)/g, '${{ steps.tests.outputs.TESTS_FAILED }}');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
        env:
          COVERAGE_LINES: ${{ steps.tests.outputs.COVERAGE_LINES }}
          COVERAGE_FUNCTIONS: ${{ steps.tests.outputs.COVERAGE_FUNCTIONS }}
          COVERAGE_BRANCHES: ${{ steps.tests.outputs.COVERAGE_BRANCHES }}
          COVERAGE_STATEMENTS: ${{ steps.tests.outputs.COVERAGE_STATEMENTS }}
          TESTS_FAILED: ${{ steps.tests.outputs.TESTS_FAILED }}

  # Job 3: Security Scan
  security-scan:
    name: security-scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run dependency vulnerability check
        id: audit
        run: |
          echo "Running npm audit..."
          npm audit --audit-level=moderate > audit-results.txt 2>&1 || echo "AUDIT_FAILED=true" >> $GITHUB_OUTPUT
          cat audit-results.txt
          
      - name: Scan for secrets in code changes
        id: secrets
        run: |
          echo "Scanning for potential secrets..."
          # Use a simple regex pattern to detect potential secrets
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            git diff ${{ github.event.pull_request.base.sha }} ${{ github.sha }} > diff.txt || true
          else
            git show --name-only > diff.txt || true
          fi
          
          # Look for common secret patterns
          SECRET_PATTERNS="(password|secret|key|token|private)=[\"'][^\"']{8,}[\"']"
          SECRET_FINDINGS=$(grep -i -E "$SECRET_PATTERNS" diff.txt || true)
          
          if [ -n "$SECRET_FINDINGS" ]; then
            echo "Potential secrets found in code changes"
            echo "$SECRET_FINDINGS" > secret-findings.txt
            echo "SECRETS_FOUND=true" >> $GITHUB_OUTPUT
          else
            echo "No obvious secrets detected"
            echo "SECRETS_FOUND=false" >> $GITHUB_OUTPUT
            echo "No secrets detected" > secret-findings.txt
          fi
          
      - name: Post Security Scan Report
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');
            
            let auditResults = '';
            let secretFindings = '';
            
            try {
              auditResults = fs.readFileSync('audit-results.txt', 'utf8');
            } catch (e) {
              auditResults = 'No audit results found';
            }
            
            try {
              secretFindings = fs.readFileSync('secret-findings.txt', 'utf8');
            } catch (e) {
              secretFindings = 'No secret scan results found';
            }
            
            const auditFailed = core.getInput('audit-failed') === 'true';
            const secretsFound = core.getInput('secrets-found') === 'true';
            
            const statusIcon = (condition) => condition ? '❌' : '✅';
            
            const commentBody = `## Security Scan Report
            
            ### Dependencies Vulnerabilities
            ${statusIcon(auditFailed)} npm audit ${auditFailed ? 'found issues' : 'passed'}
            
            \`\`\`bash
            ${auditResults.substring(0, 1500)}
            \`\`\`
            
            ### Secrets Detection
            ${statusIcon(secretsFound)} Secret scan ${secretsFound ? 'found potential secrets' : 'passed'}
            
            \`\`\`bash
            ${secretFindings.substring(0, 1500)}
            \`\`\`
            
            ### Recommendations
            - Review any found vulnerabilities and update dependencies
            - Ensure no secrets are committed to the repository
            - Use environment variables for sensitive data
            
            ---
            *Generated by PR Automation Workflow*`.replace(/core.getInput\('audit-failed'\)/g, '${{ steps.audit.outputs.AUDIT_FAILED }}').replace(/core.getInput\('secrets-found'\)/g, '${{ steps.secrets.outputs.SECRETS_FOUND }}');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
        env:
          AUDIT_FAILED: ${{ steps.audit.outputs.AUDIT_FAILED }}
          SECRETS_FOUND: ${{ steps.secrets.outputs.SECRETS_FOUND }}

  # Job 4: Build Validation
  build-validation:
    name: build-validation
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build application
        id: build
        run: |
          echo "Building application..."
          npm run build > build-results.txt 2>&1
          BUILD_EXIT_CODE=$?
          
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "BUILD_FAILED=true" >> $GITHUB_OUTPUT
            echo "Build failed with exit code $BUILD_EXIT_CODE"
          else
            echo "Build completed successfully"
          fi
          
          cat build-results.txt
          
      - name: Start application for validation
        id: start-app
        if: steps.build.outputs.BUILD_FAILED != 'true'
        run: |
          echo "Starting application for endpoint validation..."
          npm start &
          APP_PID=$!
          echo "APP_PID=$APP_PID" >> $GITHUB_OUTPUT
          
          # Wait for app to start
          sleep 5
          
          # Check if app is running
          if ps -p $APP_PID > /dev/null; then
            echo "Application started successfully (PID: $APP_PID)"
            echo "APP_RUNNING=true" >> $GITHUB_OUTPUT
          else
            echo "Application failed to start"
            echo "APP_RUNNING=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Validate endpoints
        id: validate
        if: steps.start-app.outputs.APP_RUNNING == 'true'
        run: |
          echo "Validating application endpoints..."
          
          # Test health endpoint
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/health || echo "000")
          echo "Health endpoint status: $HEALTH_STATUS"
          
          if [ "$HEALTH_STATUS" = "200" ]; then
            echo "HEALTH_CHECK_PASSED=true" >> $GITHUB_OUTPUT
          else
            echo "HEALTH_CHECK_PASSED=false" >> $GITHUB_OUTPUT
          fi
          
          # Test API endpoint if it exists
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api || echo "000")
          echo "API endpoint status: $API_STATUS"
          
          # Stop the application
          if [ -n "${{ steps.start-app.outputs.APP_PID }}" ]; then
            kill ${{ steps.start-app.outputs.APP_PID }} 2>/dev/null || true
          fi
          
      - name: Create deployment artifacts
        if: steps.build.outputs.BUILD_FAILED != 'true'
        run: |
          echo "Creating deployment preview artifacts..."
          mkdir -p deployment-preview
          cp -r src/ package*.json README.md deployment-preview/
          tar -czf deployment-preview.tar.gz deployment-preview/
          
      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        if: steps.build.outputs.BUILD_FAILED != 'true'
        with:
          name: deployment-preview
          path: deployment-preview.tar.gz
          retention-days: 7
          
      - name: Post Build Validation Report
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');
            
            let buildResults = '';
            try {
              buildResults = fs.readFileSync('build-results.txt', 'utf8');
            } catch (e) {
              buildResults = 'No build results found';
            }
            
            const buildFailed = core.getInput('build-failed') === 'true';
            const appRunning = core.getInput('app-running') === 'true';
            const healthCheckPassed = core.getInput('health-check-passed') === 'true';
            
            const statusIcon = (condition) => condition ? '✅' : '❌';
            
            const commentBody = `## Build Validation
            
            ### Build Process
            ${statusIcon(!buildFailed)} Build ${buildFailed ? 'failed' : 'succeeded'}
            
            \`\`\`bash
            ${buildResults.substring(0, 1500)}
            \`\`\`
            
            ### Application Status
            - Application Start: ${statusIcon(appRunning)} ${appRunning ? 'Successful' : 'Failed'}
            - Health Check: ${statusIcon(healthCheckPassed)} ${healthCheckPassed ? 'Passed' : 'Failed'}
            
            ### Deployment Preview
            ${!buildFailed ? '✅ Deployment artifacts created successfully' : '❌ No artifacts created due to build failure'}
            
            ### Next Steps
            ${buildFailed ? '- Fix build errors before merging' : '- Build is ready for deployment preview'}
            ${!healthCheckPassed && appRunning ? '- Investigate health check failures' : ''}
            
            ---
            *Generated by PR Automation Workflow*`.replace(/core.getInput\('build-failed'\)/g, '${{ steps.build.outputs.BUILD_FAILED }}').replace(/core.getInput\('app-running'\)/g, '${{ steps.start-app.outputs.APP_RUNNING }}').replace(/core.getInput\('health-check-passed'\)/g, '${{ steps.validate.outputs.HEALTH_CHECK_PASSED }}');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
        env:
          BUILD_FAILED: ${{ steps.build.outputs.BUILD_FAILED }}
          APP_RUNNING: ${{ steps.start-app.outputs.APP_RUNNING }}
          HEALTH_CHECK_PASSED: ${{ steps.validate.outputs.HEALTH_CHECK_PASSED }}